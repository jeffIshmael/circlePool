{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-dfb9e8a4b8676621493c043d1bc7e86ddcfb9b77",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/CirclePool.sol": "project/contracts/CirclePool.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/CirclePool.sol": {
        "content": "/**\n * @title CirclePool - this smart contract manages circles on Hedera\n * @author Jeff Muchiri\n */\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\ncontract CirclePool {\n    uint public totalCircles;\n    uint public totalPayments;\n\n    address public aiAgent;\n    address public owner;\n    \n    constructor() {\n        owner = msg.sender;\n        aiAgent = msg.sender;\n    }\n\n    struct Circle {\n        uint circleId;\n        uint amount;\n        uint startDate;\n        uint payDate;\n        uint duration;\n        uint maxMembers;\n        uint cycle; //disbursements\n        uint round; // whole rotation(everyone has gotten)\n        uint interestPercent; // After a micro-loan a member returns with this interestPercent\n        uint leftPercent; // the percentage left for the circle after a payout\n        address admin; \n        uint loanableAmount;      \n        address[] members;\n        address[] payoutOrder;//order on how the payment is done\n        mapping(address => uint) balances;\n        mapping(address => bool) hasSent;\n        mapping(address => uint) userLoan;\n\n    }\n\n    Circle[] public circles;\n\n    //Records of withdrawals - payments\n    struct Payment {\n        uint id;\n        uint circleId;\n        address receiver;\n        uint amount;\n        uint timestamp;\n    }\n\n    Payment[] public payments;\n\n    event CircleRegistered(uint indexed id,  uint amount, uint duration, uint maxMembers, uint startDate,uint interestPercent, uint leftPercent,  address indexed admin);\n    event CashDeposited(uint indexed circleId, address indexed receiver, uint amount);\n    event FundsDisbursed(uint indexed circleId, address indexed recipient, uint amount);\n    event RefundIssued(uint indexed circleId, address indexed member, uint amount);\n    event amountWithdrawn( address indexed _address, uint amount);\n    event MemberAdded(uint indexed _circleId , address indexed   _address);\n    event PayoutOrderSet(uint indexed _circleId, address [] indexed _payoutOrder);\n    event MemberRemoved(uint indexed _circleId, address indexed _member);\n    event CircleDeleted(uint indexed _circleId);\n    event PayOutProcessed( address indexed _receiver, uint _amount);\n    event WithdrawalRecorded(uint indexed _circleId, address indexed _receiver, uint  _amount);\n    event RefundUpdated( uint indexed _circleId);\n    event MemberAddedToPayoutOrder(uint indexed _circleId, address[] indexed _member);\n    event aiAgentSet(address indexed _aiAgent);\n    event PayDateChecked(uint indexed _circleId, bool _isPastPayDate, bool _isAllMembersContributed, bool isDisbursed);\n    event TransferDone(address indexed _receiver, uint _amount, bool _success, uint _contractBal, uint _receiverBalBefore); \n    event PayoutDone(uint indexed _circleId, address indexed _receiver, uint _amount);\n    event LoanPaid(uint indexed circleId, address indexed member, uint amount);    \n    event LoanProcessed(uint indexed circleId, address indexed member, uint amount);            \n   \n\n    // Register a new circle\n    function registerCircle(\n        uint _amount, \n        uint _duration, \n        uint _startDate, \n        uint _maxMembers, \n        uint _percentageInterest,\n        uint _percentageLeft) public {\n        require(_startDate >= block.timestamp, \"Start date must be in the future.\");\n        require(_duration > 0, \"Duration must be greater than 0.\");\n        require(_amount > 0, \"Amount must be greater than 0.\");\n        require(_maxMembers <= 15,\"Maximum number of members is 15.\");\n        require(_percentageInterest >= 1, \"Interest should be above 1%.\");\n        require(_percentageLeft >= 10, \"The percentage being left should be at least 10%.\");\n        \n\n        Circle storage newCircle = circles.push();\n        newCircle.circleId = totalCircles;\n        newCircle.amount = _amount;\n        newCircle.startDate = _startDate;\n        newCircle.duration = _duration;\n        newCircle.maxMembers = _maxMembers;\n        newCircle.payDate = _startDate + _duration * 24 * 60 * 60;\n        newCircle.admin = msg.sender;\n        newCircle.members.push(msg.sender);\n        newCircle.cycle = 1;\n        newCircle.round = 1;\n        newCircle.interestPercent = _percentageInterest;\n        newCircle.leftPercent = _percentageLeft;\n        newCircle.balances[msg.sender] = 0;\n        newCircle.hasSent[msg.sender] = false;\n\n\n        totalCircles++;\n\n        emit CircleRegistered(\n            totalCircles - 1, \n            _amount,\n            _maxMembers, \n            _duration, \n            _startDate, \n            _percentageInterest,\n            _percentageLeft, \n            msg.sender\n        );\n    }\n    \n    // Add a member to the circle\n    function addMember(address _address, uint _circleId) public onlyAdmin(_circleId) {\n        require(_circleId < circles.length, \"The circleId does not exist\");\n        require(!isMember(_circleId, _address), \"The address is already a member.\");\n        Circle storage circle = circles[_circleId];\n        require(circle.members.length < 15, \"Circle already has max members.\");\n        circle.members.push(_address);\n         if(block.timestamp < circle.startDate && circle.payoutOrder.length > 0){\n            circle.payoutOrder.push(_address);\n        }\n        emit MemberAdded(_circleId, _address);\n    }\n\n    // Deposit cash to a circle using native HBAR\n      function depositCash(uint _circleId) public payable onlyMembers(_circleId) {\n        require(_circleId < totalCircles, \"Circle does not exist\");\n        Circle storage circle = circles[_circleId];\n        \n        uint _amount = msg.value;\n        require(_amount > 0, \"Amount must be greater than 0\");\n\n        // Calculate actual deposit excluding 5% fee\n        uint netAmount = (_amount * 100) / 105;\n\n        // Update balance\n        circle.balances[msg.sender] += netAmount;\n\n        // Mark as paid if reached required amount\n        if (circle.balances[msg.sender] >= circle.amount) {\n            circle.hasSent[msg.sender] = true;\n        }\n        \n        emit CashDeposited(_circleId, msg.sender, _amount);\n    }\n\n     // function to loan from the available loan\n    function processLoan (address _member, uint _circleId, uint _amount) public onlyAiAgent{\n        // validity checking\n        require(_member != address(0), \"Use a valid address.\");\n        require(_amount >0 ,\"Enter a valid amount.\");\n        require(_circleId < totalCircles, \"Circle does not exist\");\n        // require the address is a member\n        require(isMember( _circleId, _member), \"The address is not a member.\");\n         Circle storage circle = circles[_circleId];\n        // require the address doesnt have a loan\n        require(circle.userLoan[_member] == 0, \"The member has a loan and needs to first repay.\");\n        // require the balance is there\n        require (circle.loanableAmount >= _amount, \"Amount higher than available to loan.\");\n\n        // Transfer HBAR to member\n        (bool sent, ) = payable(_member).call{value: _amount}(\"\");\n        require(sent, \"HBAR transfer failed\");\n\n        // updating states\n        circle.userLoan[_member] = _amount + (_amount * circle.interestPercent) / 100;\n        circle.loanableAmount -= _amount;\n\n        emit LoanProcessed(_circleId, _member, _amount);        \n    }\n\n    // function to repay loan :- No restrictions to allow them to pay from any address\n     function repayLoan (address _member, uint _circleId) public payable {\n        // validity checking\n        require(_member != address(0), \"Use a valid address.\");\n        uint _amount = msg.value;\n        require(_amount > 0, \"Enter a valid amount.\");\n        require(_circleId < totalCircles, \"Circle does not exist\");\n        // require the address is a member\n        require(isMember( _circleId, _member), \"The address is not a member.\");\n         Circle storage circle = circles[_circleId];\n        // require the address doesnt have a loan\n        require(circle.userLoan[_member] > 0, \"The member has no loan yet.\");\n\n        // updating states\n        require(_amount <= circle.userLoan[_member], \"Amount exceeds outstanding loan\");\n        circle.userLoan[_member] -= _amount;\n        circle.loanableAmount += _amount;\n\n        emit LoanPaid(_circleId, _member, _amount);        \n    }\n\n\n\n    //function to add member to the payout order\n    // check the aiAgent thing\n    function addMemberToPayoutOrder(uint _circleId, address[] memory _member) public onlyAiAgent {\n        \n        Circle storage circle = circles[_circleId];\n        // ensure its not in the middle of a round\n        require(circle.round == 1, \"Cannot add member to payout order during an active round\");\n        // ensure the member is a member of the circle\n        for (uint i = 0; i < _member.length; i++) {\n            require(isMember(_circleId, _member[i]), \"Member is not a member of the circle\");\n        }\n        // add the member to the payout order\n        for (uint i = 0; i < _member.length; i++) {\n            circle.payoutOrder.push(_member[i]);\n        }\n        emit MemberAddedToPayoutOrder(_circleId, _member);\n    }\n\n   // function to check if all contributed\n   function _allMembersContributed(uint _circleId) private view returns (bool) {\n    Circle storage circle = circles[_circleId];\n    \n    for (uint i = 0; i < circle.members.length; i++) {\n        uint membersBalance = circle.balances[circle.members[i]];\n        if (membersBalance < circle.amount) {\n            return false;\n        }\n    }\n    return true;\n    }\n    \n    // internal check\n    function allMembersContributed(uint _circleId) internal view returns (bool) {\n    return _allMembersContributed(_circleId);\n    }\n    \n    // public checking\n    function checkAllMembersContributed(uint _circleId) public view returns (bool) {\n        return _allMembersContributed(_circleId);\n    }\n\n    \n\n    //function to process payout in native HBAR\n    function processPayout(address _receiver, uint _amount) internal {\n        (bool success, ) = payable(_receiver).call{value: _amount}(\"\");\n        emit TransferDone(_receiver, _amount, success, 0, 0);\n        require(success, \"Transfer failed\");\n        emit PayOutProcessed(_receiver, _amount);\n    }\n\n    //function to record all withdrawal function\n    function recordWithdrawal(uint _circleId, address _receiver, uint _amount) internal {\n         // Record the payment\n        payments.push(Payment({\n        id: totalPayments,\n        circleId: _circleId,\n        receiver: _receiver,\n        amount: _amount,\n        timestamp: block.timestamp\n        }));\n\n        totalPayments++;\n\n        emit WithdrawalRecorded(_circleId, _receiver, _amount);\n        \n    }\n\n    // Disburse funds to a member\n    function disburse(uint _circleId) internal {\n        Circle storage circle = circles[_circleId];        \n        require(circle.payoutOrder.length > 0, \"Payout order is empty\");\n        address recipient = circle.members[(circle.round - 1) % circle.payoutOrder.length];\n        uint totalPay = circle.amount * circle.members.length;\n\n        // Calculate total available funds: sum of all balances + sum of all lockedAmounts (for public circles)\n        uint totalAvailable = 0;\n        for (uint i = 0; i < circle.payoutOrder.length; i++) {\n            address member = circle.payoutOrder[i];\n            totalAvailable += circle.balances[member];\n        }\n        require(totalAvailable >= totalPay, \"Not enough funds to disburse\");\n\n\n        // Now, all members have contributed their required amount\n        // Proceed to transfer totalPay to recipient\n        processPayout(recipient, totalPay);\n\n        // Record the withdrawal\n        recordWithdrawal(_circleId, recipient, totalPay);\n\n        // Reset payment status for the next round and deduct balances\n        for (uint i = 0; i < circle.payoutOrder.length; i++) {\n            circle.hasSent[circle.payoutOrder[i]] = false;\n            circle.balances[circle.payoutOrder[i]] -= circle.amount;\n        }\n\n        // Check if we have completed a rotation\n        if (circle.round + 1 > circle.payoutOrder.length) {\n            circle.cycle += 1; // Increment the round after one rotation\n            circle.round = 1;\n        }else{\n            circle.round += 1;\n        }\n        circle.payDate += circle.duration * 24 * 60 * 60;\n\n        emit FundsDisbursed(_circleId, recipient, totalPay);\n    }\n\n   \n\n    // Function to delete a member (admin or self)\n    function deleteMember(uint _circleId, address _member) public onlyMembers(_circleId) {\n        Circle storage circle = circles[_circleId];\n        require(msg.sender == circle.admin || msg.sender == _member, \"Only admin or the member can delete\");\n\n        // Check if circle.cycle is divisible by members.length\n        require(circle.members.length > 0, \"No members to remove\");\n        require(circle.round == 1, \"Cannot delete member during an active cycle\");\n\n        // Refund the member's balance if greater than zero\n        uint refundAmount = circle.balances[_member];\n        if (refundAmount > 0) {\n            //transfer the money back to the member\n            processPayout(_member, refundAmount);\n\n            //record the withdrawal\n            recordWithdrawal(_circleId, _member, refundAmount);\n            circle.balances[_member] = 0; // Reset the balance\n        }\n\n\n        // Remove member from members array\n        for (uint i = 0; i < circle.members.length; i++) {\n            if (circle.members[i] == _member) {\n                circle.members[i] = circle.members[circle.members.length - 1]; // Replace with the last member\n                circle.members.pop(); // Remove the last member\n                break;\n            }\n        }\n        \n        // Remove member from payout order \n        for (uint i = 0; i < circle.payoutOrder.length; i++) {\n            if (circle.payoutOrder[i] == _member) {\n                circle.payoutOrder[i] = circle.payoutOrder[circle.payoutOrder.length - 1];\n                circle.payoutOrder.pop();\n                break;\n            }\n        }\n\n        emit MemberRemoved(_circleId, _member);\n    }\n\n    // Function to delete a circle (admin only) \n    // ensure that no one has a loan andd that the amount loanable is divided among members\n    function deleteCircle(uint _circleId) public onlyAdmin(_circleId) {\n        Circle storage circle = circles[_circleId];\n\n         // ensure there is no active round\n        require(circle.members.length > 0, \"No members to remove\");\n        require(circle.round == 1, \"Cannot delete member during an active cycle\");\n\n        // Refund all members\n        refund(_circleId);\n\n        // Remove the circle by swapping with the last element and then popping\n        Circle storage lastCircle = circles[circles.length - 1];\n        circles[_circleId].circleId = lastCircle.circleId;\n        circles[_circleId].amount = lastCircle.amount;\n        circles[_circleId].startDate = lastCircle.startDate;\n        circles[_circleId].payDate = lastCircle.payDate;\n        circles[_circleId].duration = lastCircle.duration;\n        circles[_circleId].cycle = lastCircle.cycle;\n        circles[_circleId].round = lastCircle.round;\n        circles[_circleId].admin = lastCircle.admin;\n        circles[_circleId].members = lastCircle.members;\n        circles[_circleId].payoutOrder = lastCircle.payoutOrder;\n        circles.pop();\n\n        emit CircleDeleted(_circleId);\n    }\n\n   // Check pay date and trigger payout or refund\n    function checkPayDate(uint[] memory circleIds) public onlyAiAgent {\n        for (uint i = 0; i < circleIds.length; i++) {\n            uint circleId = circleIds[i];\n            require(circleId < totalCircles, \"Circle does not exist\");\n            Circle storage circle = circles[circleId];\n            bool isPastPayDate = block.timestamp >= circle.payDate;\n            bool isAllMembersContributed = allMembersContributed(circleId);\n            require(isPastPayDate, \"Pay date has not passed\");\n            bool isDisbursed;\n            // Check if the current time has passed the pay date\n            if (isPastPayDate) {\n                if (isAllMembersContributed) {\n                    disburse(circleId); // Disburse funds if everyone has paid\n                    isDisbursed = true;\n                } else {\n                    refund(circleId); // Refund if not everyone has paid\n                    isDisbursed = false;\n                }\n            }\n            emit PayDateChecked(circleId, isPastPayDate, isAllMembersContributed, isDisbursed);\n        }\n    }\n\n   // Function to check the balance of a specific address in a specific circle\n    function getBalance(uint _circleId, address _member) public view returns (uint[] memory) {\n        require(_circleId < totalCircles, \"Circle does not exist\");\n        \n        Circle storage circle = circles[_circleId];\n        \n        // Create a fixed-size array with 2 elements\n        uint [] memory balances = new uint[](2);\n        \n        // Assign the balance and locked amounts\n        balances[0] = circle.balances[_member];\n        balances[1] = circle.userLoan[_member];\n        \n        // Return the balance and user's loan\n        return balances;\n    }\n\n    // function to get the balance of each member in a circle\n   function getEachMemberBalance(uint _circleId) public view returns (address[] memory, uint[][] memory) {\n    require(_circleId < totalCircles, \"Circle does not exist.\");    \n    Circle storage circle = circles[_circleId];\n    \n    uint memberCount = circle.members.length;\n    \n    address[] memory memberAddresses = new address[](memberCount);\n    uint[][] memory balances = new uint[][](memberCount);\n    \n    for (uint i = 0; i < memberCount; i++) {\n        address member = circle.members[i];\n        memberAddresses[i] = member;\n\n        uint [] memory memberBalance = new uint[](2);\n        // Assign the balance and locked amounts\n        memberBalance[0] = circle.balances[member];\n        memberBalance[1] = circle.userLoan[member];\n\n        balances[i] = memberBalance;\n    }\n\n    return (memberAddresses, balances);\n    }\n\n\n    // Set the shuffled payout order (off-chain generated)\n    function setPayoutOrder(uint _circleId, address[] memory _payoutOrder) public onlyAiAgent {\n        require(_payoutOrder.length == circles[_circleId].members.length, \"Payout order length mismatch\");\n        Circle storage circle = circles[_circleId];\n        circle.payoutOrder = _payoutOrder;\n        emit PayoutOrderSet(_circleId, _payoutOrder);\n    }\n\n    // Refund the cash if the startDate passes and not all members have paid\n    function refund(uint _circleId) internal {\n        Circle storage circle = circles[_circleId];\n\n        for (uint i = 0; i < circle.members.length; i++) {\n            address member = circle.members[i];\n            uint refundAmount = circle.balances[member];\n            if (refundAmount > 0) {\n                //transfer the money back to the member\n                processPayout(member, refundAmount);\n\n                //record the withdrawal\n                recordWithdrawal(_circleId, member, refundAmount);\n\n                circle.balances[member] = 0;\n\n                emit RefundIssued(_circleId, member, refundAmount);\n            }\n        }\n        // Reset payment status for the next round\n        for (uint i = 0; i < circle.members.length; i++) {\n            circle.hasSent[circle.members[i]] = false;\n        }\n         if (circle.cycle + 1 > circle.members.length) {\n        circle.round += 1; // Increment the round after one rotation\n        }\n        circle.payDate += circle.duration  * 24 * 60 * 60;\n        circle.cycle++;\n        emit RefundUpdated( _circleId);\n    }\n\n    // Get all payments\n    function getPayments() public view returns (Payment[] memory) {\n        return payments;\n    }\n\n    // Get all circles\n   function getCircles() public view returns (\n    uint[] memory, \n    uint[] memory, \n    uint[] memory, \n    uint[] memory, \n    uint[] memory, \n    address[] memory\n    ) {\n    uint[] memory circleIds = new uint[](circles.length);\n    uint[] memory amounts = new uint[](circles.length);\n    uint[] memory startDates = new uint[](circles.length);\n    uint[] memory durations = new uint[](circles.length);\n    uint[] memory loanableAmounts = new uint[](circles.length);        \n    address[] memory admins = new address[](circles.length);\n\n    for (uint i = 0; i < circles.length; i++) {\n        Circle storage circle = circles[i];\n        circleIds[i] = circle.circleId;\n        amounts[i] = circle.amount;\n        startDates[i] = circle.startDate;\n        durations[i] = circle.duration;\n        loanableAmounts[i] = circle.loanableAmount;                \n        admins[i] = circle.admin;\n        }\n\n    return (circleIds, amounts, startDates, durations,loanableAmounts, admins);\n    \n}\n\n    //function to get circle by id\n   function getCircle(uint _circleId) public view returns (\n    uint,\n    uint,\n    uint,\n    uint,\n    uint,\n    uint,\n    address,\n    address[] memory,\n    uint,\n    uint,\n    uint\n    ) {\n        Circle storage circle = circles[_circleId];\n        return (circle.payDate,circle.amount,circle.startDate,circle.duration,circle.round,circle.cycle,circle.admin,circle.members,circle.loanableAmount, circle.interestPercent, circle.leftPercent);\n    }\n\n    //function to get a circle payout order\n    function getCirclePayoutOrder(uint _circleId) public view returns (address[] memory) {\n        Circle storage circle = circles[_circleId];\n        return circle.payoutOrder;\n    }\n\n    //function to check that one is member\n    function isMember(uint _circleId, address _user) internal view returns (bool) {\n        Circle storage circle = circles[_circleId];\n        for (uint i = 0; i < circle.members.length; i++) {\n            if (circle.members[i] == _user) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Modifier to restrict function access to members of a circle\n    modifier onlyMembers(uint _circleId) {\n        bool isAMember = false;\n        for (uint i = 0; i < circles[_circleId].members.length; i++) {\n            if (msg.sender == circles[_circleId].members[i]) {\n                isAMember = true;\n                break;\n            }\n        }\n        require(isAMember, \"You are not a member of the circle.\");\n        _;\n    }\n\n   //function to withdraw HBAR from the contract (owner only)\n  function emergencyWithdraw(address _address, uint _amount) public onlyOwner {\n      (bool sent, ) = payable(_address).call{value: _amount}(\"\");\n      require(sent, \"Transfer failed\");\n      emit amountWithdrawn(_address, _amount);\n  }\n\n   //function to set aiAgent (owner only)\n   function setAiAgent(address _aiAgent) public onlyOwner {\n       require(_aiAgent != address(0), \"Invalid address\");\n       aiAgent = _aiAgent;\n       emit aiAgentSet(_aiAgent);\n   }\n   \n   //modifier for only Admin\n   modifier onlyAdmin(uint _circleId){\n    require(circles[_circleId].admin == msg.sender, \"only the admin can add a member\");\n    _;\n   }\n\n   //modifier for aiAgent\n   modifier onlyAiAgent() {\n       require(msg.sender == aiAgent || msg.sender == owner, \"Only aiAgent or owner\");\n       _;\n   }\n\n   //modifier for owner\n   modifier onlyOwner() {\n       require(msg.sender == owner, \"Only owner can call this function\");\n       _;\n   }\n}\n"
      }
    }
  }
}